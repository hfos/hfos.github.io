<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XJTU 2023小学期ACM个人题解</title>
    <url>/2023/06/29/xjtuacm/</url>
    <content><![CDATA[<html><head></head><body><p><img src="/images/bugcat.gif" alt="可爱猫猫虫"></p>
<p>很酷，只写做法。</p>
<span id="more"></span>

<h2 id="Day-01-绪论"><a href="#Day-01-绪论" class="headerlink" title="Day 01 绪论"></a>Day 01 绪论</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>答案分别为 $ O(n)$，$O(1)$，$O(n^2)$，$O(n \log n) $，$O(2^n) $，$ O(n) $，$ O(n) $。</p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>对偶数和奇数分别排序。</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>分别考虑每个二进制位 $i$，对每个二进制位$ i $，数出 $ 1 … n $ 中该位为 1 的数的个数为 $x_i$ ，答案为 $ \mathop{\sum}\limits_{i=0}^{32} x_i (n+1-x_i) {2}^i $。</p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>当最大的数大于$n$时，无解。</p>
<p>当所有数为$2$时且$n$为奇数时，无解。</p>
<p>其他情况都可以这么构造：只要没凑满 $n$ 就尽量用大的数凑。</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>折半枚举。</p>
<h2 id="Day-02-贪心"><a href="#Day-02-贪心" class="headerlink" title="Day 02 贪心"></a>Day 02 贪心</h2><h3 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h3><p>尽量选小的数。</p>
<h3 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h3><p>以 $b/a$ 为权排序，比较时写成 $b_i a_j &lt; b_j a_i $。</p>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><p>按照Day 01 D的方法凑</p>
<h3 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h3><p>从左往右选，每次在能选的里选右端点尽可能右的。</p>
<h3 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h3><p>先转化为曼哈顿距离。</p>
<p>先考虑偶数的情况，考虑同时最大化两个维度。</p>
<p>观察一维上取最优的情况为：按照坐标大小把点分成两堆，其中一堆比另一堆的每一个都大且两堆个数相同；这时各从两堆中任取点两两相连，最终答案是最优的。</p>
<p>对于二维的情况，我们按照x维度分成a，b两个集合，按照y维度分成1，2两个集合。所有点就能被分入四个集合a1,a2,b1,b2，其中a1和b2等势，a2和b1等势。a1连b2，a2连b1，就能保证同时最大化两个维度的答案。</p>
<p>奇数的情况，我们跑四次。每次调整分堆时的个数分配（小的比大的多1，或大的比小的多1），结果上相当于分别向a1,a2,b1,b2中的某个集合中比正常情况多放一个点。枚举那个比正常情况多1个点的集合中哪个点是奇点并实时更新答案，这样就可以考虑全所有点为奇点的情况。</p>
<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>我们把每个交易方案超出b的部分称为“垃圾”。枚举我们所选的交换方案的最大的“垃圾”大小，可以注意到我们先交换“垃圾”大的再交换“垃圾”小的肯定不会使得我们手上的垃圾增加，所以我们要按照“垃圾”从大到小的顺序来选取方案。然后对每种材料，我们补足时尽量选择“垃圾”最小的方案，且每次补足时用任意的别的从来没有成为过我们作为补足目标、且存在方案可以补足的材料种类来交换，模拟着填，找到方案就输出，枚举完了还没找到方案就报告无解。$O({n^2}m)$卡卡能过。</p>
<h2 id="Day-03-分治"><a href="#Day-03-分治" class="headerlink" title="Day 03 分治"></a>Day 03 分治</h2><h3 id="A-2"><a href="#A-2" class="headerlink" title="A"></a>A</h3><p>答案为 $1,2,4,8,16,…$。</p>
<h3 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h3><p>二分即可。</p>
<h3 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h3><p>用st表分别维护 &amp; 和 |。</p>
<p>最大的难点是输出时候要用\n，不要用endl。</p>
<h3 id="D-2"><a href="#D-2" class="headerlink" title="D"></a>D</h3><p><strong>在模 $K$ 意义下</strong>，矩阵快速幂算出$ A = \begin{bmatrix} 0 &amp; 1 \newline 1 &amp; 1  \end{bmatrix} ^ {M-1}$，答案为 $2(A_{0,0}+A_{0,1}) \text{ mod } K$。</p>
<h3 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h3><p>维护一个01trie，这样我们就可以维护当前某一个二进制前缀的出现次数。</p>
<p>从左到右遍历每一个 $a_i$，对某一个$a_i$，在01trie上匹配一遍并加入，对于某一个已经匹配到的二进制前缀，若将要匹配1，则答案中计入该前缀+0的出现次数*当前位的key值。时空都是$32n$的。</p>
<h2 id="Day-04-搜索"><a href="#Day-04-搜索" class="headerlink" title="Day 04 搜索"></a>Day 04 搜索</h2><h3 id="A-3"><a href="#A-3" class="headerlink" title="A"></a>A</h3><p>从起点bfs一遍。</p>
<h3 id="B-3"><a href="#B-3" class="headerlink" title="B"></a>B</h3><p>课上讲了。</p>
<h3 id="C-3"><a href="#C-3" class="headerlink" title="C"></a>C</h3><p>dfs记忆化搜索。从每个点开始dfs一下，因为记忆化了所以总复杂度是$O(nm)$的。</p>
<h3 id="D-3"><a href="#D-3" class="headerlink" title="D"></a>D</h3><p>对所有标记为 p和 @ 的点求出两两之间的最短路。然后枚举他经过的 @ 的顺序的全排列并取最优解。</p>
<h3 id="E-3"><a href="#E-3" class="headerlink" title="E"></a>E</h3><p>课上讲了。</p>
<h3 id="F-1"><a href="#F-1" class="headerlink" title="F"></a>F</h3><p>迭代加深搜索，深度很小，测试一下$1…100$的数据，能跑过就交。</p>
<h2 id="Day-05-动态规划"><a href="#Day-05-动态规划" class="headerlink" title="Day 05 动态规划"></a>Day 05 动态规划</h2><h3 id="A-4"><a href="#A-4" class="headerlink" title="A"></a>A</h3><p>令 $f_i$ 表示控制第 $1…i$ 个结点的最小时间，状态转移方程 $f_i=\mathop{\text{min}}\limits_{1 \leq j &lt; i} \big \{ f_j + v \mathop{\sum}\limits_{\scriptsize{j &lt; k \leq i}} a_k + t + 2 \mathop{\sum}\limits_{\scriptsize{j+1&lt;k \leq i}}a_k \big \} $，其中$\sum a_k$可以用前缀和算，答案为 $f_n$。</p>
<h3 id="B-4"><a href="#B-4" class="headerlink" title="B"></a>B</h3><p>令 $f_{i,j}$ 表示前 $1…i$ 个相位束中，有 $j$ 个在射击时关闭了所有护盾，此时牺牲的最少的护盾数，状态转移方程 $ f_{i,j} = \text{min} \{  f_{i-1,j-1}, \mathop{\mathop{\text{min}}\limits_{ k &gt; f_{i-1,j} }}\limits_{l_k \leq a_i \leq u_k } k \} $，答案为 $ \mathop{\text{min}}\limits_{f_{m,j}\leq n} j $。</p>
<p><strong>note：</strong>暴力找 $\mathop{\mathop{\text{min}}\limits_{ k &gt; f_{i-1,j} }}\limits_{l_k \leq a_i \leq u_k } k$ 过了，但是好像可以卡掉。这个做法随便拿个数据结构优化一下可以做到对的复杂度。</p>
<h3 id="C-4"><a href="#C-4" class="headerlink" title="C"></a>C</h3><p>取以下两个值的最大值：对区间 $1..N $做01背包的答案；对区间 $X..N$做01背包的答案加上$Q$。</p>
<h3 id="D-4"><a href="#D-4" class="headerlink" title="D"></a>D</h3><p>首先判断无解：建图，首先把所有$P_{i,j}$向$P_{i+1,j-1},P_{i+1,j},P_{i+1,j+1}$连边，然后枚举所有 $A_{i,j}&lt;0$ 的点$P_{i,j}$，连有向边$(S,P_{i,j}),(P_{i,j},T)$。显然这是个DAG，求$S$到$T$的最大权路径，若该权$&gt;0$，则无解。</p>
<p>一个比较重要的发现是他至多使用一次传送门，然后做法很随便，可以建三张图跑三次，也可以不建。</p>
<h3 id="E-4"><a href="#E-4" class="headerlink" title="E"></a>E</h3><p>对每次询问做一遍<a href="https://www.luogu.com.cn/problem/B3637">【Luogu B3637】最长上升子序列</a>，其实这里是最长不降子序列，但是做法一样。</p>
<h3 id="F-2"><a href="#F-2" class="headerlink" title="F"></a>F</h3><p>首先我们不希望有0.5元这种面值，所以所有和钱相关的数值乘2。筛一遍我们手中的货币所有能表示出来的面值，然后01背包。</p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>令 $f_i$ 为所有包含第$i$位，且对于$s_i=\text{l},\text{n},\text{c}$的情况，分别至少含一个子串为$\text{l}$、$\text{ln}$、$\text{lnc}$的，<strong>第$1…n$位的</strong>子序列的个数，转移方程 $f_i=\left \{  \begin{array}{rl} 2^{i-1}\text{ mod } 10^9 +7 &amp;,s_i=\text{l} \newline \mathop{\mathop{\sum}\limits_{1 \leq j &lt; i}} \limits_{ s_j = \text l} f_j \text{ mod } 10^9 +7  &amp;,s_i=\text{n} \newline \mathop{\mathop{\sum}\limits_{1 \leq j &lt; i}}\limits_{s_j = \text n } f_j \text{ mod } 10^9 +7  &amp;,s_i=\text{c} \end{array} \right .$，实时记录两个变量分别表示 $\mathop{\mathop{\sum}\limits_{1 \leq j \leq i}} \limits_{ s_j = \text l} f_j \text{ mod } 10^9 +7  $，$\mathop{\mathop{\sum}\limits_{1 \leq j \leq i}} \limits_{ s_j = \text n} f_j \text{ mod } 10^9 +7  $ 就可以 $O(n)$。最终答案为 $ \mathop{\sum}\limits_{s_i = \text{c}} f_i \text{ } 2^{|s|-i} \text{ mod } 10^9 +7  $。</p>
<h2 id="Day-06-数据结构"><a href="#Day-06-数据结构" class="headerlink" title="Day 06 数据结构"></a>Day 06 数据结构</h2><h3 id="A-5"><a href="#A-5" class="headerlink" title="A"></a>A</h3><p>典中典之开个栈，从后往前枚举$i=n…1$。$s_i=\text{)}$时将$i$入栈，$s_i=\text{(}$时让栈顶出栈。最后把出栈序列倒过来输出一遍。</p>
<h3 id="B-5"><a href="#B-5" class="headerlink" title="B"></a>B</h3><p>双向链表。</p>
<h3 id="C-5"><a href="#C-5" class="headerlink" title="C"></a>C</h3><p>dfs求连通块大小，然后随便枚举一下。</p>
<h3 id="D-5"><a href="#D-5" class="headerlink" title="D"></a>D</h3><p>dp，转移方程$f_i=1+\mathop{\mathop{\sum}\limits_{1\leq j &lt; i}}\limits_{| a_i-a_j | \leq d}{f_j} \text{ mod } 998244353$，开个线段树维护区间和，结点$k$的值为$\mathop{\mathop{\sum}\limits_{1 \leq j \leq i}}\limits_{a_j=k} f_j\text{ mod } 998244353$，每次转移时查询线段树上区间$[a_i -d,a_i+d]$的和再更新$a_i$点处的值就可以$O(n\log n)$。答案为 $\mathop{\sum}\limits_{1\leq i \leq n}{f_i} -n \text{ mod } 998244353$</p>
<h3 id="E-5"><a href="#E-5" class="headerlink" title="E"></a>E</h3><p>这玩意没有结合律。我们分块。考虑到运算数只有两种，我们大力记录$f_{i,0}$，$f_{i,1}$分别表示$0/1$ 依次 $\bigodot $ 第$i$块内所有元素的结果，每次操作1就依次暴力$ \bigodot $左端散块、整块和右端散块，其中$ \bigodot $整块的操作应当使用我们先前计算的$f_{i,0/1}$，操作2和操作3暴力修改一块。</p>
<p><strong>note：</strong>事实上也可以线段树。</p>
<h3 id="F-3"><a href="#F-3" class="headerlink" title="F"></a>F</h3><p>校赛题解讲得很好。</p>
<h2 id="Day-07-图论"><a href="#Day-07-图论" class="headerlink" title="Day 07 图论"></a>Day 07 图论</h2><p>课上基本上把题目做法都讲过了，课后大力贴板子过题太爽了。</p>
<h3 id="A-6"><a href="#A-6" class="headerlink" title="A"></a>A</h3><p>建图跑Dijkstra求出所有$dis(1,i)$，再把所有边反向一下，重新建个新图跑Dijkstra求出所有$dis(i,1)$。</p>
<h3 id="B-6"><a href="#B-6" class="headerlink" title="B"></a>B</h3><p>他是DAG所以很套路。不过这题数据很小所以直接贴了个spfa板子过了。</p>
<h3 id="C-6"><a href="#C-6" class="headerlink" title="C"></a>C</h3><p>该图邻接矩阵为$M$，倍增求$M^{k} \text{ mod } 998244353$，答案为$M_{1,n}$。</p>
<h3 id="D-6"><a href="#D-6" class="headerlink" title="D"></a>D</h3><p>算每条边的贡献。</p>
<h3 id="E-6"><a href="#E-6" class="headerlink" title="E"></a>E</h3><p>求出最大生成树，然后查询树上路径的边权最小值。因为这题数据很小所以直接贴了一个树剖板子过了。</p>
<h3 id="F-4"><a href="#F-4" class="headerlink" title="F"></a>F</h3><p>给查询按照权值 $w_i$ 从大到小排序，然后对询问可以单调加边，用个并查集维护当前连通块权值总和。</p>
<h2 id="Day-08-数学"><a href="#Day-08-数学" class="headerlink" title="Day 08 数学"></a>Day 08 数学</h2><p>又是课上讲题。非常好安排，爱来自数学低手。</p>
<h3 id="A-7"><a href="#A-7" class="headerlink" title="A"></a>A</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s = <span class="built_in">input</span>().split()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(s[<span class="number">0</span>]) * <span class="built_in">int</span>(s[<span class="number">1</span>]) % <span class="built_in">int</span>(s[<span class="number">2</span>]))</span><br></pre></td></tr></tbody></table></figure>

<h3 id="B-7"><a href="#B-7" class="headerlink" title="B"></a>B</h3><p>若 $x \nmid y$，输出$0$。</p>
<p>否则令 $k=\frac{y}{x}$，枚举其所有使得$\gcd (i,\frac{k}{i})=1$的因子$i$。</p>
<h3 id="C-7"><a href="#C-7" class="headerlink" title="C"></a>C</h3><p>整除分块。</p>
<h3 id="D-7"><a href="#D-7" class="headerlink" title="D"></a>D</h3><p>走的路径必然是 $x \rightarrow \gcd (x,y) \rightarrow y$。</p>
<h3 id="E-7"><a href="#E-7" class="headerlink" title="E"></a>E</h3><p>重要结论：$\gcd (x,y)=x$。</p>
<p>做法是，初始化$y \leftarrow x$，然后枚举$1…10^7$内所有素数$p_i$，若$\frac{n}{x p_i} \geq 1$，则$y \leftarrow y p_i \bmod 920011128$。</p>
<h2 id="Day-09-字符串"><a href="#Day-09-字符串" class="headerlink" title="Day 09 字符串"></a>Day 09 字符串</h2><p>咕咕咕。</p>
<h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h2><p>非常好送分捞人。</p>
<h2 id="期末考试"><a href="#期末考试" class="headerlink" title="期末考试"></a>期末考试</h2><p>最简单的一集。</p>
<h3 id="A-8"><a href="#A-8" class="headerlink" title="A"></a>A</h3><p>暴力枚举。</p>
<h3 id="B-8"><a href="#B-8" class="headerlink" title="B"></a>B</h3><p>从小到大排序后序列为$v$，答案是 $\mathop{\sum}\limits_{1\leq i \leq n}{\frac{v_i}{v_{n+i}}}$。</p>
<h3 id="C-8"><a href="#C-8" class="headerlink" title="C"></a>C</h3><p>状压dp。</p>
<h3 id="D-8"><a href="#D-8" class="headerlink" title="D"></a>D</h3><p>大力爆搜，随便剪枝。</p>
<h3 id="E-8"><a href="#E-8" class="headerlink" title="E"></a>E</h3><p>二分答案。</p>
<p><img src="/images/bugcat.gif" alt="可爱猫猫虫"><br><img src="/images/bugcat.gif" alt="可爱猫猫虫"><br><img src="/images/bugcat.gif" alt="可爱猫猫虫"></p>
<p>完结。</p>
</body></html>]]></content>
  </entry>
  <entry>
    <title>格局决定成败</title>
    <url>/2023/01/14/geJuJueDingChengBai/</url>
    <content><![CDATA[<html><head></head><body><p><a href="https://www.bilibili.com/video/BV1pN4y1c7At/">格局决定成败</a></p>
</body></html>]]></content>
  </entry>
  <entry>
    <title>“一种轻量级平衡树”学习笔记</title>
    <url>/2023/09/12/splay_alternative_tech/</url>
    <content><![CDATA[<html><head></head><body><p><img src="/images/bugcat.gif" alt="可爱猫猫虫"></p>
<p>学习并实现了<a href="https://www.luogu.com.cn/blog/command-block/yi-zhong-qing-liang-ji-ping-heng-shu">一种轻量级平衡树</a>。</p>
<span id="more"></span>

<p>一句话描述：对一个leafy结构的树，当需要分离出区间$[l,r]$时，我们保留分别严格包含于$[1,l),[l,r],(r,n]$的极大区间，删除其他结点。然后通过将这些极大区间视为叶子，暴力重构为完全二叉树来还原该树结构。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P3391">【模板】文艺平衡树</a></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">8</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	node* l;</span><br><span class="line">	node* r;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> sz;</span><br><span class="line">	<span class="type">char</span> lazy;</span><br><span class="line">	<span class="built_in">node</span>()</span><br><span class="line">	{</span><br><span class="line">		l=r=<span class="literal">nullptr</span>;</span><br><span class="line">		lazy=<span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="built_in">swap</span>(l,r);</span><br><span class="line">		lazy^=<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">}*root;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(node* tmp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(tmp-&gt;lazy==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(tmp-&gt;l!=<span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		tmp-&gt;l-&gt;<span class="built_in">rev</span>();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(tmp-&gt;r!=<span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		tmp-&gt;r-&gt;<span class="built_in">rev</span>();</span><br><span class="line">	}</span><br><span class="line">	tmp-&gt;lazy=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(node* tmp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	tmp-&gt;sz=(tmp-&gt;l==<span class="literal">nullptr</span>?<span class="number">0</span>:tmp-&gt;l-&gt;sz)+(tmp-&gt;r==<span class="literal">nullptr</span>?<span class="number">0</span>:tmp-&gt;r-&gt;sz);</span><br><span class="line">}</span><br><span class="line">vector&lt;node&gt;vec;</span><br><span class="line">vector&lt;node&gt;ll;</span><br><span class="line">vector&lt;node&gt;mm;</span><br><span class="line">vector&lt;node&gt;rr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(node* tmp,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">pushdown</span>(tmp);</span><br><span class="line">	<span class="type">int</span> L=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> R=tmp-&gt;sz;</span><br><span class="line">	<span class="keyword">if</span>(R&lt;l)</span><br><span class="line">	{</span><br><span class="line">		ll.<span class="built_in">push_back</span>(*tmp);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(l&lt;=L&amp;&amp;R&lt;=r)</span><br><span class="line">	{</span><br><span class="line">		tmp-&gt;<span class="built_in">rev</span>();</span><br><span class="line">		mm.<span class="built_in">push_back</span>(*tmp);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(r&lt;L)</span><br><span class="line">	{</span><br><span class="line">		rr.<span class="built_in">push_back</span>(*tmp);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(tmp-&gt;l!=<span class="literal">nullptr</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">split</span>(tmp-&gt;l,l,r);</span><br><span class="line">			l=l-tmp-&gt;l-&gt;sz;</span><br><span class="line">			r=r-tmp-&gt;l-&gt;sz; </span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(tmp-&gt;r!=<span class="literal">nullptr</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">split</span>(tmp-&gt;r,l,r);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">delete</span> tmp;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(node* tmp,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	{</span><br><span class="line">		(*tmp)=vec[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(tmp-&gt;l=<span class="keyword">new</span> <span class="built_in">node</span>(),l,mid);</span><br><span class="line">	<span class="built_in">build</span>(tmp-&gt;r=<span class="keyword">new</span> <span class="built_in">node</span>(),mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">pushup</span>(tmp);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(node* tmp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(tmp==<span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">pushdown</span>(tmp);</span><br><span class="line">	<span class="keyword">if</span>(tmp-&gt;l==<span class="literal">nullptr</span>&amp;&amp;tmp-&gt;r==<span class="literal">nullptr</span>) cout&lt;&lt;tmp-&gt;val&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(tmp-&gt;l);</span><br><span class="line">	<span class="built_in">dfs</span>(tmp-&gt;r);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	root=<span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">	{</span><br><span class="line">		node t;</span><br><span class="line">		t.val=i;</span><br><span class="line">		t.sz=<span class="number">1</span>;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(t);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">build</span>(root,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="comment">//dfs(root);cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;"bref: ";dfs(root);cout&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(l==<span class="number">1</span>&amp;&amp;r==n)</span><br><span class="line">		{</span><br><span class="line">			root-&gt;<span class="built_in">rev</span>();</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			ll.<span class="built_in">clear</span>();</span><br><span class="line">			mm.<span class="built_in">clear</span>();</span><br><span class="line">			rr.<span class="built_in">clear</span>();</span><br><span class="line">			vec.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="built_in">split</span>(root,l,r);</span><br><span class="line">			<span class="built_in">reverse</span>(mm.<span class="built_in">begin</span>(),mm.<span class="built_in">end</span>());</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> i:ll) vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> i:mm) vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> i:rr) vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">			root=<span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">			<span class="built_in">build</span>(root,<span class="number">0</span>,vec.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//cout&lt;&lt;"test: ";dfs(root);cout&lt;&lt;endl;</span></span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">dfs</span>(root);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P3960">P3960 [NOIP2017 提高组] 列队</a></p>
<p>空间复杂度是 $O(n+m)$ 的。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">3e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	node* l;</span><br><span class="line">	node* r;</span><br><span class="line">	<span class="type">int</span> L,R;</span><br><span class="line">	<span class="type">int</span> sz;</span><br><span class="line">}Pool[maxn];</span><br><span class="line">node* pool[maxn];</span><br><span class="line"><span class="type">int</span> st=<span class="number">0</span>;</span><br><span class="line"><span class="function">node* <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	node* tmp=pool[st++];</span><br><span class="line">	tmp-&gt;l=tmp-&gt;r=<span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delnode</span><span class="params">(node* tmp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pool[--st]=tmp;</span><br><span class="line">}</span><br><span class="line">vector&lt;node*&gt;vt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(node*&amp; root,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//cout&lt;&lt;"build "&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	{</span><br><span class="line">		root=vt[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	root=<span class="built_in">newnode</span>();</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(root-&gt;l,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(root-&gt;r,mid+<span class="number">1</span>,r);</span><br><span class="line">	root-&gt;sz=root-&gt;l-&gt;sz+root-&gt;r-&gt;sz;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;"sz "&lt;&lt;root-&gt;sz&lt;&lt;" "&lt;&lt;1+root-&gt;l-&gt;sz+root-&gt;r-&gt;sz&lt;&lt;endl;</span></span><br><span class="line">}</span><br><span class="line">vector&lt;node*&gt;ll,mm,rr;</span><br><span class="line">node* tar;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(node* root,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//cout&lt;&lt;"split "&lt;&lt;root-&gt;L&lt;&lt;" "&lt;&lt;root-&gt;R&lt;&lt;" "&lt;&lt;root-&gt;sz&lt;&lt;endl;</span></span><br><span class="line">	<span class="type">int</span> R=root-&gt;sz;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=<span class="number">1</span>&amp;&amp;R&lt;=r)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//cout&lt;&lt;"mm "&lt;&lt;root-&gt;L&lt;&lt;" "&lt;&lt;root-&gt;R&lt;&lt;endl;</span></span><br><span class="line">		mm.<span class="built_in">push_back</span>(root);</span><br><span class="line">		tar=root;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(R&lt;l)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//cout&lt;&lt;"ll "&lt;&lt;root-&gt;L&lt;&lt;" "&lt;&lt;root-&gt;R&lt;&lt;endl;</span></span><br><span class="line">		ll.<span class="built_in">push_back</span>(root);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(r&lt;<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//cout&lt;&lt;"rr "&lt;&lt;root-&gt;L&lt;&lt;" "&lt;&lt;root-&gt;R&lt;&lt;endl;</span></span><br><span class="line">		rr.<span class="built_in">push_back</span>(root);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(root-&gt;l==<span class="literal">nullptr</span>&amp;&amp;root-&gt;r==<span class="literal">nullptr</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1</span>&lt;l)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">auto</span> tmp=<span class="built_in">newnode</span>();</span><br><span class="line">				tmp-&gt;L=root-&gt;L;</span><br><span class="line">				tmp-&gt;R=root-&gt;L+l<span class="number">-2</span>;</span><br><span class="line">				tmp-&gt;sz=l<span class="number">-1</span>;</span><br><span class="line">				mm.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">auto</span> tmp=<span class="built_in">newnode</span>();</span><br><span class="line">			tmp-&gt;L=root-&gt;L+l<span class="number">-1</span>;</span><br><span class="line">			tmp-&gt;R=root-&gt;L+r<span class="number">-1</span>;</span><br><span class="line">			tmp-&gt;sz=r-l+<span class="number">1</span>;</span><br><span class="line">			mm.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">			tar=tmp;</span><br><span class="line">			<span class="keyword">if</span>(r&lt;R)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">auto</span> tmp=<span class="built_in">newnode</span>();</span><br><span class="line">				tmp-&gt;L=root-&gt;L+r;</span><br><span class="line">				tmp-&gt;R=root-&gt;R;</span><br><span class="line">				tmp-&gt;sz=R-r;</span><br><span class="line">				mm.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(root-&gt;l!=<span class="literal">nullptr</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">split</span>(root-&gt;l,l,r);</span><br><span class="line">			l-=root-&gt;l-&gt;sz;</span><br><span class="line">			r-=root-&gt;l-&gt;sz; </span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(root-&gt;r!=<span class="literal">nullptr</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">split</span>(root-&gt;r,l,r);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">delnode</span>(root);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">node* heng[<span class="number">300000</span>+<span class="number">5</span>];</span><br><span class="line">node* shu;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;++i) pool[i]=Pool+i;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,m,q;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;"? "&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">300000</span>+<span class="number">5</span>;++i) heng[i]=<span class="built_in">newnode</span>(),heng[i]-&gt;L=<span class="number">1</span>+(i<span class="number">-1</span>)*m,heng[i]-&gt;R=m<span class="number">-1</span>+(i<span class="number">-1</span>)*m,heng[i]-&gt;sz=m<span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;"t 1"&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">auto</span> tmp=<span class="built_in">newnode</span>();</span><br><span class="line">		tmp-&gt;L=tmp-&gt;R=i*m;</span><br><span class="line">		tmp-&gt;sz=<span class="number">1</span>;</span><br><span class="line">		vt.<span class="built_in">push_back</span>(tmp); </span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//cout&lt;&lt;"t 1"&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">build</span>(shu,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="comment">//cout&lt;&lt;"t 1"&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		<span class="keyword">if</span>(y==m)</span><br><span class="line">		{</span><br><span class="line">			ll.<span class="built_in">clear</span>();rr.<span class="built_in">clear</span>();mm.<span class="built_in">clear</span>();vt.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="built_in">split</span>(shu,x,x);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> i:ll) vt.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> i:rr) vt.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> i:mm) vt.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="built_in">build</span>(shu,<span class="number">0</span>,vt.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">			<span class="comment">//for(auto i:vt) cout&lt;&lt;"t "&lt;&lt;i-&gt;L&lt;&lt;" "&lt;&lt;i-&gt;R&lt;&lt;endl;</span></span><br><span class="line">			cout&lt;&lt;mm[<span class="number">0</span>]-&gt;L&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			ll.<span class="built_in">clear</span>();rr.<span class="built_in">clear</span>();mm.<span class="built_in">clear</span>();vt.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="built_in">split</span>(heng[x],y,y);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> i:ll) vt.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> i:mm) <span class="keyword">if</span>(i!=tar) vt.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> i:rr) vt.<span class="built_in">push_back</span>(i);</span><br><span class="line">			node* tmp=tar;</span><br><span class="line">			cout&lt;&lt;tmp-&gt;L&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">			ll.<span class="built_in">clear</span>();rr.<span class="built_in">clear</span>();mm.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="built_in">split</span>(shu,x,x);</span><br><span class="line">			<span class="comment">//for(auto i:vt) cout&lt;&lt;"tq "&lt;&lt;i-&gt;L&lt;&lt;" "&lt;&lt;i-&gt;R&lt;&lt;endl;</span></span><br><span class="line">			vt.<span class="built_in">push_back</span>(mm[<span class="number">0</span>]);</span><br><span class="line">			<span class="comment">//for(auto i:vt) cout&lt;&lt;"tq "&lt;&lt;i-&gt;L&lt;&lt;" "&lt;&lt;i-&gt;R&lt;&lt;endl;</span></span><br><span class="line">			<span class="built_in">build</span>(heng[x],<span class="number">0</span>,vt.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">			vt.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> i:ll) vt.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> i:rr) vt.<span class="built_in">push_back</span>(i);</span><br><span class="line">			vt.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">			<span class="comment">//for(auto i:vt) cout&lt;&lt;"t2 "&lt;&lt;i-&gt;L&lt;&lt;" "&lt;&lt;i-&gt;R&lt;&lt;endl;</span></span><br><span class="line">			<span class="built_in">build</span>(shu,<span class="number">0</span>,vt.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用感想：常数比splay大，但是直观好学，是一种优秀的平衡树。</p>
</body></html>]]></content>
  </entry>
</search>
